本题最容易想到的思路应该是双指针线性扫描两个数组，时间复杂度为(m + n)，不符合进阶要求。现提供log(m + n)的解法如下：
我们知道，快速选择出数组中第K个数的快速选择算法使用了分治的思想，本题的思想与之类似，都是将问题拆解为一个个的子问题，然后分别处理。

* 首先，求中位数要先看数组的总长度，如果为偶数，则中位数是中间两个数的平均值`((nums[length / 2] + nums[length / 2 + 1]) / 2)`；如果为奇数，则中位数为最中间的数`(nums[length / 2 + 1])`.
* 如果直接递归求解中位数，不太容易找到思路，我们可以选择一种更通用的解法，即找出两个数组中第k小的元素，然后按照上面所说的求中位数的方法得到中位数

那么如何求出两个数组中第k小的数？我们考虑先分别求出两个数组中第k/2个元素(由于数组是有序的，所以取出的元素在原数组中是第k/2小的元素)。然后有三种情况：
> 我们假设第一个数组为A，第二个数组为B
> 1. `A[k / 2] < B[k / 2]`
>    * 因为两个数组都是有序的，所以在A数组中，A[0] ~ A[k / 2 - 1]都要小于等于A[k / 2]，也就是说在数组A中有 k / 2 个元素要小于等于A[k / 2](包括A[k / 2])
>    * 而在B数组中，由于B[k / 2] > A[k / 2], 所以B数组前 k / 2 个元素中，小于等于A[k / 2]的最多有 k / 2 - 1个(极限情况，即只有B[k / 2]要大于A[k / 2]，而B[0] ~ B[k / 2 - 1]都要小于A[k / 2]).
>    * 两个数组中小于等于A[k / 2]的数为A数组中 k / 2个，B数组中最多 k / 2 - 1 个，一共最多有k - 1个数小于等于A[k / 2]，所以A数组中从A[0] ~ A[k / 2]这些数都不可能是第K个数
>    * 这样我们就将问题变为了在剩下的数中寻找第(k - k / 2(下取整))小的值
> 
> 2. `A[k / 2] > B[k / 2]`
>    * 分析过程同上，可以得出B数组中从B[0] ~ B[k / 2]这些数都不可能是第K个数
> 3. `A[k / 2] == B[k / 2]`
>    * A数组中小于等于A[k / 2]的数有 k / 2 - 1个(去除A[k / 2])，B数组中小于等于B[k / 2]的数有 k / 2 - 1个(去除B[k / 2])，然后加上A[k / 2], B[k / 2]，刚刚好有K个数小于等于A[k / 2](或B[k / 2])，所以第K小的数恰好就是A[k / 2](或B[k / 2]，二者相等)

这样，我们每次都可以排除掉k / 2个数，而K的值最多减到1，即找到两个数组中第1小的值(即两个数组中的最小值)，这样我们就找到了递归的基础情况。
时间复杂度分析：`k=(m+n)/2`，且每次递归 k 的规模都减少一半，因此时间复杂度是 `O(log(m+n))`


```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        //求出两个数组的总长度
        int total = nums1.length + nums2.length;
        //如果是奇数，则求出中间两个数的平均数
        if((total & 1) == 0) {
            int left = find(nums1, 0, nums2, 0, total / 2);
            int right = find(nums1, 0, nums2, 0, total / 2 + 1);
            return (left + right) / 2.0;    //求平均数，注意要除2.0，否则会下取整
        }
        //如果是偶数，则直接返回中位数
        return (double) find(nums1, 0, nums2, 0, total / 2 + 1);
    }

    /**
    参数: nums1, nums2: 两个数组
          i, j分别为nums1, nums2的起始位置
          k为要求的第K小的数
    **/
    private int find(int[] nums1, int i, int[] nums2, int j, int k) {
        //为了方便，我们使nums1的长度小于nums2的长度
        if(nums1.length - i > nums2.length - j) {
            return find(nums2, j, nums1, i, k);
        }
        //如果nums1的起始位置已经与其长度相等，则nums1中的数已经用光了，返回nums2中第K小的数
        if(nums1.length == i) {
            return nums2[j + k - 1];
        }
        //如果k等于1，则相当与求出两个数组中的最小值，直接返回nums1[i], nums2[j]中较小的一个
        if(k == 1) {
            return Math.min(nums1[i], nums2[j]);
        }
        //si表示我们上面所说的A[k / 2]后面的那个数的下标。
        //此处si与nums1的长度取最小值，因为可能会出现i + k / 2 > num1.length的情况
        int si = Math.min(nums1.length, i + k / 2);
        //sj与si表示的含义相同，表示B[k / 2]后面的那个数的下标
        //这里使用sj = j + k - k / 2是为了保证以该点为分界线的数组的前半部分的总长与A数组中前半部分的总长度的和为k。
        //因为如果k是奇数，如果si,sj都使用k/2，则导致总数比k少1
        //例如：k = 5, i = j = 0
        //此时si = 5 / 2 = 2, 如果sj使用j + k / 2, 则sj = 5 / 2 = 2, 2 + 2 = 4 < 5.
        int sj = j + k - k / 2;

        //如果nums1[si - 1] > nums2[sj - 1],对应上面的情况二
        if(nums1[si - 1] > nums2[sj - 1]) {
            //由于去除了从j 到 sj 之间的数，所以原本的第K小的数在新数组中为第k - (sj - j)小的数
            return find(nums1, i, nums2, sj, k - (sj - j));
        }
        //如果nums2[si - 1] <= nums[sj - 1],对应上面的1， 3
        //此处不应该把情况3单独拿出来，因为可能会出现一种边界情况，即i + k / 2 > nums1.length
        //如果按照上面情况3的讨论，我们可以返回nums1[si] 或 nums2[sj]，但是此时因为nums1长度不足了，所以nums[si]并不是两个数组中第k小的数
        else  {
            return find(nums1, si, nums2, j, k - (si - i));
        }
        
    }
}
```
